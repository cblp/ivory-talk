$newline text

<section>
    <h2> Производительный код <nobr>на Haskell</nobr>
    <p> Юрий Сыровецкий
    <p> разработчик, Лаборатория Касперского

<section>
    <h3> Мы создаём
    <ul>
        <li> системное ПО
        <li> компоненты операционных систем
        <li> компоненты системного ПО
        <li> инструменты для управления этими компонентами

<section>
    <h3> Нам нужны
    <ul>
        <li> гарантированное время выполнения
        <li> гарантированное потребление памяти
        <li> возможность ручного управления памятью
        <li> поддержка определённых редких архитектур
        <li> простота расширения и взаимодействия с кодом, написанным другими разработчиками

<section>
    <h3> <nobr>Решение —</nobr> писать <nobr>на C</nobr>

<section>
    <h3> Ещё нам нужны
    <ul>
        <li> гарантии корректности кода
        <li> выразительность кода
        <li> язык высокого уровня (полиморфизм и прочие достижения цивилизации)

<section>
    <h3> <nobr>Решение —</nobr> писать <nobr>на C</nobr>
        \ и проверять код на ошибки статическим анализатором
    <ul>
        <li> уменьшает необходимость писать тесты
        <li> но не даёт гарантию корректности

<section>
    <h3> Решение <nobr>лучше —</nobr> писать <nobr>на Haskell</nobr> метапрограммы,
        \ порождающие код <nobr>на C</nobr>

<section>
    <h2> Способ 0. <br> Текстовая шаблонизация
    <ul>
        <li> просто
        <li> можно уменьшить boilerplate
        <li> но никаких существенных преимуществ перед обычным С

<section>
    <h2> Способ 1. <br> Библиотеки <br> <code>language-c</code>, <br> <code>language-c-quote</code>

<section>
    <section>
        <h3> <code>language-c-quote</code>: хеллоуворлд
        <pre>
            <code>
                \main = do
                \  msg:_ &lt;- getArgs
                \  putDoc $ ppr [cunit|
                \    $esc:("#include &lt;stdio.h>")
                \    int main() {
                \      puts($string:msg);
                \    }
                \  |]
    <section>
        <h3> Получившееся AST
        <pre>
            <code>
                \[ EscDef "#include &lt;stdio.h>"
                \, FuncDef
                \    (OldFunc
                \       (DeclSpec [] [] (Tint Nothing))
                \       (Id "main")
                \       (DeclRoot)
                \       []
                \       Nothing
                \       [ BlockStm (Exp
                \           (Just (FnCall (Var (Id "puts"))
                \              [ Const ( StringConst
                \                  "CoLaboratory: ruHaskell 2016" ) ] ) ) ) ] ) ]

<section>
    <h3> <code>language-c-quote</code>: достоинства
    <ul>
        <li> QuasiQuotes — можно писать почти как на C,
            \ код может править С-программист, не знающий Haskell
        <li> проверка синтаксиса C при написании
        <li> простые типы для работы с AST —
            \ при необходимости можно обработать AST привычными средствами (Generics, SYB...)
        <li> антицитата <code>$esc</code> позволяет вставить произвольный код при необходимости

<section>
    <h3> <code>language-c-quote</code>: чего не хватает
    <ul>
        <li> всё ещё нет проверки корректности кода
            <ul>
                <li> то, что может проверить GCC, но можно бы ещё раньше
                    \ (например, соответствие типов, дублирование символов)
                <li> то, чего не может проверить GCC
                    \ (например, сильное соответствие типов, целочисленное переполнение и т. д.)
        <li> всё ещё надо писать тривиальные тесты

<section>
    <h3> <code>language-c-quote</code>: подводные камни
    <ul>
        <li> не поддерживаются вложенные цитаты в антицитатах
        <li> необходимость <code>$esc</code> для <code>#include</code>

<section>
    <h2> Способ 2. <br> Библиотека-DSL Ivory

<section>
    <section>
        <h3> Ivory: хеллоуворлд
        <pre>
            <code>
                \puts :: Def ('[IString] ':-> ())
                \puts = importProc "puts" "stdio.h"
                \
                \cmain :: String -> Def ('[] ':-> Sint32)
                \cmain msg = proc "main" $ body $ do
                \  call_ puts (fromString msg)
                \  ret 0
                \
                \hello msg = package "ivory-hello" $ do
                \  incl puts
                \  incl (cmain msg)
                \
                \main = do
                \  msg:rest &lt;- getArgs
                \  withArgs rest $ C.compile [hello msg] []
    <section>
        <h3> Сгенерированный код
        <code>ivory-hello.h
        <pre>
            <code>
                \#include &lt;stdio.h>
                \#include "ivory.h"
                \int32_t main(void);
        <code>ivory-hello.c
        <pre>
            <code>
                \#include "ivory-hello.h"
                \
                \int32_t main(void) {
                \    puts("CoLaboratory: ruHaskell 2016");
                \    return (int32_t) 0;
                \}

<section>
    <h3> Ivory: особенности
    <ul>
        <li> код пишется <nobr>ни на C</nobr>, <nobr>ни на «настоящем»</nobr> Haskell,
            \ <nobr>а на «языке</nobr> Ivory»
        <li> «обычный» Haskell-код выполняется <nobr>во время</nobr> генерации C-кода
        <li> Ivory-код <nobr>не выполняется</nobr>, <nobr>а транслируется</nobr> <nobr>в C</nobr>

<section>
    <section>
        <h3> Ivory: использование Haskell <nobr>для умных</nobr> макросов
        <pre>
            <code>
                \class CPrint a where
                \  cprint :: a -> Ivory eff ()
                \
                \instance CPrint Uint32 where
                \  cprint n = call_ printf "%u\n" n
                \
                \instance CPrint IString where
                \  cprint s = call_ puts s
                \
                \cmain = proc "main" $ body $ do
                \  cprint (2016 :: Uint32)
                \  cprint ("CoLaboratory: ruHaskell" :: IString)
                \  ret 0
    <section>
        <h3> Сгенерированный код
        <pre>
            <code>
                \int32_t main(void) {
                \    printf("%u\n", (uint32_t) 2016U);
                \    puts("CoLaboratory: ruHaskell");
                \    return (int32_t) 0;
                \}

<section>
    <section>
        <h3> Ivory: использование Haskell <nobr>для контроля</nobr> типов

    <section>
        <h4> Пример: безопасный вызов <code>qsort</code>
        <table .simple>
            <tr>
                <td>
                    сигнатура <nobr>в C</nobr>
                <td width="100%">
                    <pre>
                        <code class=c>
                            \void
                            \qsort(
                            \    void * base,
                            \    size_t nel,
                            \    size_t width,
                            \    int (* compar)(const void *, const void *)
                            \);
            <tr>
                <td>
                    импорт <nobr>в Ivory</nobr>
                <td width="100%">
                    <pre>
                        <code>
                            \_qsort :: Def ('[ Ptr s (Stored ())
                            \                , Size
                            \                , Size
                            \                , Ptr s (Stored ()) ]
                            \              :-> ())
                            \_qsort = importProc "qsort" "stdlib.h"
    <section>
        <table .simple>
            <tr>
                <td>
                    безопасный интерфейс
                <td width="100%">
                    <pre>
                        <code>
                            \type CompareProc s area =
                            \    Def ('[ ConstRef s area
                            \          , ConstRef s area ]
                            \        :-> IInt)
                            \
                            \qsortBy :: CompareProc s area
                            \        -> Ref s (Array n area)
                            \        -> Ivory eff ()
    <section>
        <h4> Использование
        <pre>
            <code>
                \cmp_u8_rev :: CompareProc s (Stored Uint8)
                \cmp_u8_rev = proc "cmp_u8_rev" $ \px py -> body $ do
                \    x &lt;- deref px
                \    y &lt;- deref py
                \    ret $ safeCast y - safeCast x
                \
                \cmain :: Def ('[] ':-> IInt)
                \cmain = proc "main" $ body $ do
                \    let exampleData = "CoLaboratory: ruHaskell 2016"
                \    exampleArray &lt;- local (iarray $
                \        map (ival . fromIntegral . ord) exampleData
                \        :: Init (AString 32))
                \    puts exampleArray
                \    qsortBy cmp_u8_rev exampleArray
                \    puts exampleArray
                \    ret 0
    <section>
        <h4> Реализация
        <pre>
            <code>
                \type CompareProc s area =
                \    Def ('[ConstRef s area, ConstRef s area] :-> IInt)
                \
                \qsortBy ::
                \    forall s n area eff .
                \    (KnownNat n, IvoryArea area, IvorySizeOf area) =>
                \    CompareProc s area -> Ref s (Array n area) -> Ivory eff ()
                \qsortBy compareProc array =
                \    call_ _qsort
                \        (ivoryCast array)
                \        (fromInteger $ natVal (Proxy :: Proxy n))
                \        (sizeOf (Proxy :: Proxy area))
                \        (ivoryCast' (procPtr compareProc))

<section>
    <h3> Ivory: достоинства
    <ul>
        <li> корректность кода на входе гарантируется системой типов Haskell
        <li> корректность кода на выходе гарантируется библиотекой #
            <code>language-c-quote</code>
        <li> предусмотрены способы защиты от многих UB и UB
        <li> исправлена слабая типизация языка C
        <li> вместо «костыля» <nobr>CPP —</nobr> хорошо типизированные #
            полиморфные макросы на Haskell
            <ul>
                <li> имитация полиморфизма в C

<section>
    <h3> Ivory: больше достоинств
    <ul>
        <li> генерация poperty тестов QuickCheck
        <li> аналитическая проверка свойств (model checking)
            <ul>
                <li> исходного кода на Ivory с помощью SMT-решателя CVC4
                <li> результирующего кода на C с помощью CBMC
        <li> <code>Expr</code> как <nobr>символьный тип данных —</nobr>
            кодогенерация <nobr>из любого</nobr> достаточно обобщённого кода

<section>
    <h3> Ivory: недостатки фундаметальные
    <ul>
        <li> мало документации
        <li> Ivory /= <nobr>Haskell —</nobr> <nobr>не все</nobr> #
            возможности Haskell можно транслировать <nobr>в C</nobr>
        <li> Ivory /= <nobr>C —</nobr> <nobr>не все</nobr> #
            возможности языка C покрываются языком Ivory
        <li> программист должен хорошо разбираться и в C, #
            и в Haskell на уровне типов

<section>
    <h3> Ivory: недостатки практические
    <ul>
        <li> константы <nobr>для C</nobr> должны быть известны #
            <nobr>на этапе</nobr> компиляции <nobr>Haskell —</nobr> #
            приходится добавлять ещё один уровень кодогенерации #
            (Template Haskell)
        <li> неудобства <nobr>при работе</nobr> <nobr>с типами</nobr>, #
            структурами <nobr>и процедурами</nobr>, #
            определёнными <nobr>в C</nobr>

<section>
    <h3> Выводы
    <ol>
        <li> Haskell облегчает написание и генерацию кода на C.
        <li> И language-c-quote, и Ivory хороши. Каждый со своими ограничениями.
