$newline text

<section>
    <h2> Производительный <nobr>и безопасный</nobr> код <nobr>на Haskell</nobr>
    <p> Юрий Сыровецкий <br> разработчик, Лаборатория Касперского

<section>
    <p> Мы разрабатываем безопасную платформу:
    <ul>
        <li> Kaspersky Security System
        <li> KasperskyOS
        <li> Kaspersky Secure Hypervisor
    <p> На Haskell пишем системные компоненты и инструменты для управления этими компонентами

<section>
    <h3> Нам нужны
    <ul>
        <li> гарантированное время выполнения
        <li> гарантированное потребление памяти
        <li> возможность ручного управления памятью
        <li> поддержка встраиваемых систем и специализированных архитектур
        <li> простота расширения и взаимодействия с кодом, написанным другими разработчиками

<section>
    <h3> <nobr>Решение —</nobr> писать <nobr>на C</nobr>
    <ul>
        <li> <nobr>C —</nobr> невероятно мощный
        <li> <nobr>и столь же</nobr> опасный инструмент

<section>
    <h3> Нам нужны
    <p> гарантии корректности кода
    <h3> Мы хотим
    <p> язык высокого уровня (выразительность и прочие достижения цивилизации)

<section>
    <h3> <nobr>Решение —</nobr> писать <nobr>на C</nobr>
        \ <nobr>и проверять</nobr> код <nobr>на ошибки</nobr> статическим анализатором
    <ul>
        <li> не уменьшает необходимость писать тесты
        <li> не даёт гарантий корректности

<section>
    <h3> Решение <nobr>лучше —</nobr> писать <nobr>на Haskell</nobr> метапрограммы,
        \ порождающие код <nobr>на C</nobr>

<section>
    <h2> Способ 0. <br> Текстовая шаблонизация
    <ul>
        <li> просто
        <li> можно уменьшить boilerplate
        <li> <nobr>но нет</nobr> существенных преимуществ перед обычным #
            С <nobr>с препроцессором</nobr>

<section>
    <h2> Способ 1. <br> Библиотеки <br> <code>language-c</code>, <br> <code>language-c-quote</code>

<section>
    <h3> <code>language-c-quote</code>: хеллоуолд
    <pre>
        <code>
            \main = do
            \    msg:_ &lt;- getArgs
            \    putDoc $ ppr [cunit|
            \        $esc:("#include &lt;stdio.h>")
            \        int main() {
            \            puts($string:msg);
            \            return 0;
            \        }
            \    |]

<section>
    <h3> <code>language-c-quote</code>: AST хеллоуворлда
    <pre>
        <code>
            \[ EscDef "#include &lt;stdio.h>"
            \, FuncDef
            \    (OldFunc
            \       (DeclSpec [] [] (Tint Nothing))
            \       (Id "main")
            \       (DeclRoot)
            \       []
            \       Nothing
            \       [ BlockStm (Exp
            \           (Just (FnCall (Var (Id "puts"))
            \              [ Const ( StringConst
            \                  "CoLaboratory: ruHaskell 2016")])))
            \       , BlockStm (Return
            \           (Just (Const (IntConst "0" Signed 0))))])]

<section>
    <h3> <code>language-c-quote</code>: сгенерированный код хеллоуворлда
    <pre>
        <code>
            \#include &lt;stdio.h>
            \int main() {
            \    puts("CoLaboratory: ruHaskell 2016");
            \    return 0;
            \}

<section>
    <h3> <code>language-c-quote</code>: достоинства
    <ul>
        <li> QuasiQuotes — можно писать почти как на C,
            \ код может читать С-программист, <nobr>не знающий</nobr> Haskell
        <li> проверка синтаксиса C при написании
        <li> простые типы для работы <nobr>с AST —</nobr>
            \ можно обработать AST привычными средствами (Generics, SYB...)
        <li> антицитата <code>$esc</code> позволяет вставить произвольный код при необходимости

<section>
    <h3> <code>language-c-quote</code>: чего не хватает
    <ul>
        <li> никак не ограничивает нас <nobr>в использовании</nobr> С
        <li> всё ещё нет проверки корректности кода
            <ul>
                <li> то, что может проверить GCC, но можно бы ещё раньше
                    \ (например, соответствие типов, дублирование символов)
                <li> то, чего не может проверить GCC
                    \ (например, сильное соответствие типов, целочисленное переполнение и т. д.)

<section>
    <h3> <code>language-c-quote</code>: подводные камни
    <ul>
        <li> не поддерживаются вложенные цитаты в антицитатах
        <li> необходимость <code>$esc</code> для <code>#include</code>

<section>
    <h2> Способ 2. <br> Библиотека-DSL Ivory
    <ul>
        <li> eDSL <nobr>с ограниченными</nobr> <nobr>возможностями —</nobr> #
            это убирает целые классы ошибок
        <li> можно транслировать <nobr>не только</nobr> <nobr>в текст</nobr> <nobr>на C</nobr>, #
            <nobr>но и в другие</nobr> представления (например, для автоматических доказательств)

<section>
    <h3> Ivory: хеллоуолд
    <pre style="box-shadow: none;">
        <code .fragment>
            \puts :: Def ('[IString] ':-> IInt)
            \puts = importProc "puts" "stdio.h"
            \
        <code>
            \cmain :: String -> Def ('[] ':-> IInt)
            \cmain msg = proc "main" $ body $ do
            \    call_ puts (fromString msg)
            \    ret 0
            \
            \hello msg = package "ivory-hello" $ do
            \    incl puts
            \    incl (cmain msg)
        <code .fragment>
            \
            \main = do
            \    msg:rest &lt;- getArgs
            \    withArgs rest $ C.compile [hello msg] []

<section>
    <h3> Ivory: сгенерированный код хеллоуворлда
    <code>ivory-hello.h
    <pre>
        <code>
            \#include &lt;stdio.h>
            \#include "ivory.h"
            \int32_t main(void);
    <code>ivory-hello.c
    <pre>
        <code>
            \#include "ivory-hello.h"
            \
            \int32_t main(void) {
            \    puts("CoLaboratory: ruHaskell 2016");
            \    return (int32_t) 0;
            \}

<section data-background-image="codegen.blockdiag.svg">

<section>
    <h3> Ivory: использование Haskell <nobr>для умных</nobr> макросов
    <pre>
        <code>
            \class CPrint a where
            \    cprint :: a -> Ivory eff ()
            \
            \instance CPrint IString where
            \    cprint s = call_ puts s
            \
            \instance CPrint Uint32 where
            \    cprint n = call_ printf "%u\n" n
            \
            \cmain = proc "main" $ body $ do
            \    cprint ("CoLaboratory: ruHaskell" :: IString)
            \    cprint (2016 :: Uint32)
            \    ret 0

<section>
    <h3> Ivory: cгенерированный код умных макросов
    <pre>
        <code>
            \int32_t main(void) {
            \    puts("CoLaboratory: ruHaskell");
            \    printf("%u\n", (uint32_t) 2016U);
            \    return (int32_t) 0;
            \}

<section>
    <h3> Ivory: гарантии безопасности

<section>
    <h4> Пример: безопасная сумма элементов массива
    <pre>
        <code>
            \csum :: KnownNat n
            \     => Def ('[ ConstRef -- (1) указатель не null
            \                -- ^ (2) данные не изменяются
            \                  s
            \                  ('Array n ('Stored Uint32)) ]
            \                       -- ^ доступно n ячеек памяти
            \            ':-> Uint32)
            \csum = proc "sum" $ \xs -> body $ do
            \    r &lt;- local izero
            \    arrayMap $ \i -> do
            \        s &lt;- deref r
            \        x &lt;- deref (xs ! i)
            \        -- ^ (3) -- i :: Ix n
            \        -- значения 'i' ограничены размером массива
            \        -- не произойдёт выход за границы массива
            \        store r (s + x)
            \    ret =&lt;&lt; deref r

<section>
    <h3> Ivory: использование Haskell <nobr>для контроля</nobr> типов процедур <nobr>на C</nobr>

<section>
    <h4> Пример: безопасный вызов <code>qsort</code>
    <table .simple>
        <tr>
            <td>
                сигнатура <nobr>в C</nobr>
            <td width="100%">
                <pre>
                    <code class=c>
                        \void
                        \qsort(
                        \    void * base,
                        \    size_t nel,
                        \    size_t width,
                        \    int (* compar)(const void *, const void *)
                        \);
        <tr>
            <td>
                импорт <nobr>в Ivory</nobr>
            <td width="100%">
                <pre>
                    <code>
                        \_qsort :: Def ('[ Ptr s (Stored ())
                        \                , Size
                        \                , Size
                        \                , Ptr s (Stored ()) ]
                        \              :-> ())
                        \_qsort = importProc "qsort" "stdlib.h"
<section>
    <h4> <code>qsortBy</code>: безопасный интерфейс
    <pre>
        <code>
            \type CompareProc s area =
            \    Def ('[ ConstRef s area
            \          , ConstRef s area ]
            \        :-> IInt)
            \
            \qsortBy :: CompareProc s area
            \        -> Ref s (Array n area)
            \        -> Ivory eff ()

<section>
    <h4> <code>qsortBy</code>: использование
    <pre>
        <code>
            \cmp_u8_rev :: CompareProc s (Stored Uint8)
            \cmp_u8_rev = proc "cmp_u8_rev" $ \px py -> body $ do
            \    x &lt;- deref px
            \    y &lt;- deref py
            \    ret $ safeCast y - safeCast x
            \
            \cmain = proc "main" $ body $ do
            \    ...
            \    qsortBy cmp_u8_rev exampleArray
            \    ...

<section>
    <h4> <code>qsortBy</code>: реализация
    <pre>
        <code>
            \type CompareProc s area =
            \    Def ('[ConstRef s area, ConstRef s area] :-> IInt)
            \
            \qsortBy ::
            \    forall s n area eff .
            \    (KnownNat n, IvoryArea area, IvorySizeOf area) =>
            \    CompareProc s area -> Ref s (Array n area) -> Ivory eff ()
            \qsortBy compareProc array =
            \    call_ _qsort
            \        (ivoryCast array)
            \        (fromInteger $ natVal (Proxy :: Proxy n))
            \        (sizeOf (Proxy :: Proxy area))
            \        (ivoryCast' (procPtr compareProc))

<section>
    <h3> Ivory: достоинства
    <ul>
        <li> корректность кода на входе гарантируется системой типов Haskell
        <li> корректность кода на выходе гарантируется библиотекой #
            <code>language-c-quote</code>
        <li> предусмотрены способы защиты от многих UB и UB
        <li> исправлена слабая типизация языка C
        <li> вместо «костыля» <nobr>CPP —</nobr> хорошо типизированные #
            полиморфные макросы на Haskell
            <ul>
                <li> имитация полиморфизма в C

<section>
    <h3> Ivory: больше достоинств
    <ul>
        <li> <nobr><code>ivory-formal-model</code> —</nobr> #
            доказательство корректности программ <nobr>на языке</nobr> Ivory
        <li> генерация property тестов QuickCheck
            <!--пример?-->
            <ul>
                <li> можно сгенерировать тесты даже для функций, написанных <nobr>на C</nobr>
        <li> аналитическая проверка свойств (model checking)
            <ul>
                <li> исходного кода на Ivory с помощью SMT-решателя CVC4
                <li> результирующего кода на C с помощью CBMC
        <li> <code>Expr</code> как <nobr>символьный тип данных —</nobr> #
            кодогенерация <nobr>из любого</nobr> достаточно обобщённого кода (estimator)
        <li> <code>Ivory.Language.Syntax.Concrete.QQ</code> — внешний DSL

<section>
    <h3> Ivory: недостатки фундаметальные
    <ul>
        <li> мало документации
        <li> Ivory /= <nobr>Haskell —</nobr> <nobr>не все</nobr> #
            возможности Haskell можно транслировать <nobr>в C</nobr>
        <li> Ivory /= <nobr>C —</nobr> <nobr>не все</nobr> #
            возможности языка C покрываются языком Ivory
        <li> программист должен хорошо разбираться <nobr>и в C</nobr>, #
            <nobr>и в Haskell</nobr> <nobr>на уровне</nobr> типов
        <li> сообщения об ошибках бывает трудно разбирать (типично для eDSL)

<section>
    <h3> Ivory: недостатки практические
    <ul>
        <li> константы <nobr>для C</nobr> должны быть известны #
            <nobr>на этапе</nobr> компиляции <nobr>Haskell —</nobr> #
            приходится добавлять ещё один уровень кодогенерации #
            (Template Haskell)
        <li> неудобства <nobr>при работе</nobr> <nobr>с типами</nobr>, #
            структурами <nobr>и процедурами</nobr>, #
            определёнными <nobr>в C</nobr>

<section>
    <h3> Ivory: подводные камни
    <pre>
        <code .haskell>
            \do  exampleArray &lt;- local
            \        (iarray $ map ival [0, 1, 2, 3]
            \        :: Init (Array 4 (Stored Uint32)))
            \    x &lt;- deref (exampleArray ! 4)
            \    call_ printf "%u\n" x
    <p .fragment> компилируется
    <p .fragment> не падает
    <pre .fragment>
        <code>
            \0

<section>
    <h3> Ivory: альтернативы
    <table .code .simple>
        <tr>
            <td> Atom
            <td>
                <a href="http://hackage.haskell.org/package/atom">hackage.haskell.org/package/atom
        <tr>
            <td> Copilot
            <td>
                <a href="http://hackage.haskell.org/package/copilot">hackage.haskell.org/package/copilot
                <br>
                <a href="http://leepike.github.io/Copilot/">leepike.github.io/Copilot
        <tr>
            <td> Filet-o-Fish
            <td>
                <a href="https://www.microsoft.com/en-us/research/publication/filet-o-fish-practical-and-dependable-domain-specific-languages-for-os-development/">
                    microsoft.com/<wbr>en-us/<wbr>research/<wbr>publication/<wbr>filet-o-fish-practical-and-dependable-domain-specific-languages-for-os-development
        <!--<tr>
            <td> impure-->
        <tr>
            <td> SBV
            <td>
                <a href="http://hackage.haskell.org/package/sbv">hackage.haskell.org/package/sbv
                <br>
                <a href="http://leventerkok.github.io/sbv/">leventerkok.github.io/sbv
        <tr>
            <td> Tower
            <td>
                <a href="http://ivorylang.org/tower-overview.html">ivorylang.org/tower-overview.html

<section>
    <h3> Выводы
    <ol>
        <li> Haskell облегчает написание и генерацию кода на C.
        <li> И language-c-quote, и Ivory хороши. Каждый со своими ограничениями.

<section>
    <p> Юрий Сыровецкий, разработчик, Лаборатория Касперского
    <p>
        <a href="spam@kaspersky.com">
            <code>Yury.Syrovetsky@kaspersky.com
    <p>
        <a href="https://twitter.com/cblp_su">
            <code>twitter.com/cblp_su
    <p>
        <a href="https://github.com/cblp/ivory-talk/tree/master/code">
            <code>github.com/cblp/ivory-talk
