$newline text

<section>
    <h2> Производительный код <nobr>на Haskell</nobr>
    <p> Юрий Сыровецкий
    <p> разработчик, Лаборатория Касперского

<section>
    <h3> Мы создаём
    <ul>
        <li> системное ПО
        <li> компоненты операционных систем
        <li> компоненты системного ПО
        <li> инструменты для управления этими компонентами

<section>
    <h3> Нам нужны
    <ul>
        <li> гарантированное время выполнения
        <li> гарантированное потребление памяти
        <li> возможность ручного управления памятью
        <li> поддержка определённых редких архитектур
        <li> простота расширения и взаимодействия с кодом, написанным другими разработчиками

<section>
    <h3> <nobr>Решение —</nobr> писать <nobr>на C</nobr>

<section>
    <h3> Ещё нам нужны
    <ul>
        <li> гарантии корректности кода
        <li> выразительность кода
        <li> язык высокого уровня (полиморфизм и прочие достижения цивилизации)

<section>
    <h3> <nobr>Решение —</nobr> писать <nobr>на C</nobr>
        \ и проверять код на ошибки статическим анализатором
    <ul>
        <li> уменьшает необходимость писать тесты
        <li> но не даёт гарантию корректности

<section>
    <h3> Решение <nobr>лучше —</nobr> писать <nobr>на Haskell</nobr> метапрограммы,
        \ порождающие код <nobr>на C</nobr>

<section>
    <h2> Способ 0. <br> Текстовая шаблонизация
    <ul>
        <li> просто
        <li> можно уменьшить boilerplate
        <li> но никаких существенных преимуществ перед обычным С

<section>
    <h2> Способ 1. <br> Библиотеки <br> <code>language-c</code>, <br> <code>language-c-quote</code>

<section>
    <section>
        <h3> <code>language-c-quote</code>: хеллоуворлд
        <pre>
            <code>
                \main = do
                \  msg:_ &lt;- getArgs
                \  putDoc $ ppr [cunit|
                \    $esc:("#include &lt;stdio.h>")
                \    int main() {
                \      puts($string:msg);
                \    }
                \  |]
    <section>
        <h3> Получившееся AST
        <pre>
            <code>
                \[ EscDef "#include &lt;stdio.h>"
                \, FuncDef
                \    (OldFunc
                \       (DeclSpec [] [] (Tint Nothing))
                \       (Id "main")
                \       (DeclRoot)
                \       []
                \       Nothing
                \       [ BlockStm (Exp
                \           (Just (FnCall (Var (Id "puts"))
                \              [ Const ( StringConst
                \                  "CoLaboratory: ruHaskell 2016" ) ] ) ) ) ] ) ]

<section>
    <h3> <code>language-c-quote</code>: плюсы
    <ul>
        <li> QuasiQuotes — можно писать почти как на C,
            \ код может править С-программист, не знающий Haskell
        <li> проверка синтаксиса C при написании
        <li> простые типы для работы с AST —
            \ при необходимости можно обработать AST привычными средствами (Generics, SYB...)
        <li> антицитата <code>$esc</code> позволяет вставить произвольный код при необходимости

<section>
    <h3> <code>language-c-quote</code>: чего не хватает
    <ul>
        <li> всё ещё нет проверки корректности кода
            <ul>
                <li> то, что может проверить GCC, но можно бы ещё раньше
                    \ (например, соответствие типов, дублирование символов)
                <li> то, чего не может проверить GCC
                    \ (например, сильное соответствие типов, целочисленное переполнение и т. д.)
        <li> всё ещё надо писать тривиальные тесты

<section>
    <h3> <code>language-c-quote</code>: подводные камни
    <ul>
        <li> не поддерживаются вложенные цитаты в антицитатах
        <li> необходимость <code>$esc</code> для <code>#include</code>

<section>
    <h2> Способ 2. <br> Библиотека-DSL Ivory

<section>
    <section>
        <h3> Ivory: хеллоуворлд
        <pre>
            <code>
                \puts :: Def ('[IString] ':-> ())
                \puts = importProc "puts" "stdio.h"
                \
                \cmain :: String -> Def ('[] ':-> Sint32)
                \cmain msg = proc "main" $ body $ do
                \  call_ puts (fromString msg)
                \  ret 0
                \
                \hello msg = package "ivory-hello" $ do
                \  incl puts
                \  incl (cmain msg)
                \
                \main = do
                \  msg:rest &lt;- getArgs
                \  withArgs rest $ C.compile [hello msg] []
    <section>
        <h3> Сгенерированный код
        <code>ivory-hello.h
        <pre>
            <code>
                \#include &lt;stdio.h>
                \#include "ivory.h"
                \int32_t main(void);
        <code>ivory-hello.c
        <pre>
            <code>
                \#include "ivory-hello.h"
                \
                \int32_t main(void) {
                \    puts("CoLaboratory: ruHaskell 2016");
                \    return (int32_t) 0;
                \}

<section>
    <h3> Ivory: особенности
    <ul>
        <li> код пишется <nobr>ни на C</nobr>, <nobr>ни на «настоящем»</nobr> Haskell,
            \ <nobr>а на «языке</nobr> Ivory»
        <li> «обычный» Haskell-код выполняется <nobr>во время</nobr> генерации C-кода
        <li> Ivory-код <nobr>не выполняется</nobr>, <nobr>а транслируется</nobr> <nobr>в C</nobr>

<section>
    <section>
        <h3> Ivory: использование Haskell <nobr>для умных</nobr> макросов
        <pre>
            <code>
                \class CPrint a where
                \  cprint :: a -> Ivory eff ()
                \
                \instance CPrint Uint32 where
                \  cprint n = call_ printf "%u\n" n
                \
                \instance CPrint IString where
                \  cprint s = call_ puts s
                \
                \cmain = proc "main" $ body $ do
                \  cprint (2016 :: Uint32)
                \  cprint ("CoLaboratory: ruHaskell" :: IString)
                \  ret 0
    <section>
        <h3> Сгенерированный код
        <pre>
            <code>
                \int32_t main(void) {
                \    printf("%u\n", (uint32_t) 2016U);
                \    puts("CoLaboratory: ruHaskell");
                \    return (int32_t) 0;
                \}

<section>
    <section>
        <h3> Ivory: использование Haskell <nobr>для контроля</nobr> типов

    <section>
        <h4> Пример: безопасный вызов <code>qsort</code>
        <table .simple>
            <tr>
                <td>
                    сигнатура <nobr>в C</nobr>
                <td width="100%">
                    <pre>
                        <code class=c>
                            \void
                            \qsort(
                            \    void * base,
                            \    size_t nel,
                            \    size_t width,
                            \    int (* compar)(const void *, const void *)
                            \);
    <section>
        <h4> Пример: безопасный вызов <code>qsort</code>
        <table .simple>
            <tr>
                <td>
                    импорт <nobr>в Ivory</nobr>
                <td width="100%">
                    <pre>
                        <code>
                            \_qsort :: Def ('[ Ptr s (Stored ())
                            \                , Size
                            \                , Size
                            \                , Ptr s (Stored ()) ]
                            \              :-> ())
                            \_qsort = importProc "qsort" "stdlib.h"
            <tr>
                <td>
                    безопасный интерфейс
                <td width="100%">
                    <pre>
                        <code>
                            \type CompareProc s a =
                            \    Def ('[ ConstRef s (Stored a)
                            \          , ConstRef s (Stored a) ]
                            \        :-> IInt)
                            \qsortBy :: CompareProc s a
                            \        -> Ref s (Array n (Stored a))
                            \        -> Ivory eff ()
    <section>
        <h4> Использование
        <pre>
            <code>
                \cmp_u8_rev :: CompareProc s Uint8
                \cmp_u8_rev = proc "cmp_u8_rev" $ \px py -> body $ do
                \    x &lt;- deref px
                \    y &lt;- deref py
                \    ret $ safeCast x - safeCast y
                \
                \cmain :: Def ('[] ':-> IInt)
                \cmain = proc "main" $ body $ do
                \    let exampleData = "CoLaboratory: ruHaskell 2016"
                \    exampleArray &lt;- local (iarray $
                \        map (ival . fromIntegral . ord) exampleData
                \        :: Init (AString 32))
                \    puts exampleArray
                \    qsortBy cmp_u8_rev exampleArray
                \    puts exampleArray
                \    ret 0
