<section>
    <h2> Производительный код <nobr>на Haskell</nobr>
    <p> Юрий Сыровецкий
    <p> разработчик, Лаборатория Касперского

<section>
    <h3> Мы создаём
    <ul>
        <li> системное ПО
        <li> компоненты операционных систем
        <li> компоненты системного ПО
        <li> инструменты для управления этими компонентами

<section>
    <h3> Нам нужны
    <ul>
        <li> гарантированное время выполнения
        <li> гарантированное потребление памяти
        <li> возможность ручного управления памятью
        <li> поддержка определённых редких архитектур
        <li> простота расширения и взаимодействия с кодом, написанным другими разработчиками

<section>
    <h3> <nobr>Решение —</nobr> писать <nobr>на C</nobr>

<section>
    <h3> А ещё нам нужны
    <ul>
        <li> гарантии корректности кода
        <li> писать меньше кода и тестов
        <li> писать на языке высокого уровня (полиморфизм и прочие достижения цивилизации)

<section>
    <h3> <nobr>Решение —</nobr> писать <nobr>на C</nobr> #
        и проверять код на ошибки статическим анализатором
    <ul>
        <li> уменьшает необходимость писать тесты
        <li> но не даёт гарантию корректности

<section>
    <h3> Решение <nobr>лучше —</nobr> писать <nobr>на Haskell</nobr> метапрограммы, #
        порождающие код <nobr>на C</nobr>

<section>
    <h3> Способ 0. Текстовая шаблонизация
    <ul>
        <li> просто
        <li> можно уменьшить boilerplate
        <li> но никаких существенных преимуществ перед обычным С

<section>
    <h3> Способ 1. Библиотеки <br> <code>language-c</code>, <br> <code>language-c-quote</code>

<section>
    <h3> Хеллоуворлд на <code>language-c-quote</code>
    <code>
        main :: IO ()
