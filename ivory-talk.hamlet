$newline text

<section>
    <h2> Производительный код <nobr>на Haskell</nobr>
    <p> Юрий Сыровецкий
    <p> разработчик, Лаборатория Касперского

<section>
    <h3> Мы создаём
    <ul>
        <li> системное ПО
        <li> компоненты операционных систем
        <li> компоненты системного ПО
        <li> инструменты для управления этими компонентами

<section>
    <h3> Нам нужны
    <ul>
        <li> гарантированное время выполнения
        <li> гарантированное потребление памяти
        <li> возможность ручного управления памятью
        <li> поддержка определённых редких архитектур
        <li> простота расширения и взаимодействия с кодом, написанным другими разработчиками

<section>
    <h3> <nobr>Решение —</nobr> писать <nobr>на C</nobr>

<section>
    <h3> А ещё нам нужны
    <ul>
        <li> гарантии корректности кода
        <li> писать меньше кода и тестов
        <li> писать на языке высокого уровня (полиморфизм и прочие достижения цивилизации)

<section>
    <h3> <nobr>Решение —</nobr> писать <nobr>на C</nobr> #
        и проверять код на ошибки статическим анализатором
    <ul>
        <li> уменьшает необходимость писать тесты
        <li> но не даёт гарантию корректности

<section>
    <h3> Решение <nobr>лучше —</nobr> писать <nobr>на Haskell</nobr> метапрограммы, #
        порождающие код <nobr>на C</nobr>

<section>
    <h2> Способ 0. Текстовая шаблонизация
    <ul>
        <li> просто
        <li> можно уменьшить boilerplate
        <li> но никаких существенных преимуществ перед обычным С

<section>
    <h2> Способ 1. Библиотеки <br> <code>language-c</code>, <br> <code>language-c-quote</code>

<section>
    <section>
        <h3> Хеллоуворлд на <code>language-c-quote</code>
        <pre>
            <code>
                \main = do
                \    msg:_ &lt;- getArgs
                \    putDoc $ ppr [cunit|
                \        $esc:("#include &lt;stdio.h>")
                \        int main() {
                \            puts($string:msg);
                \        }
                \    |]
    <section>
        <h3> Получившееся AST
        <pre>
            <code>
                \[ EscDef "#include &lt;stdio.h>"
                \, FuncDef
                \    (OldFunc
                \       (DeclSpec [] [] (Tint Nothing))
                \       (Id "main")
                \       (DeclRoot)
                \       []
                \       Nothing
                \       [ BlockStm (Exp
                \           (Just (FnCall (Var (Id "puts"))
                \              [ Const ( StringConst
                \                  "CoLaboratory:ruHaskell 2016" ) ] ) ) ) ] ) ]

<section>
    <h3> <code>language-c-quote</code>: плюсы
    <ul>
        <li> QuasiQuotes — можно писать почти как на C, #
            код может поправить С-программист, не знающий Haskell
        <li> проверка синтаксиса C при написании
        <li> простые типы для работы с AST — #
            при необходимости можно обработать AST привычными средствами (Generics, SYB...)
        <li> антицитата <code>$esc</code> позволяет вставить произвольный код при необходимости

<section>
    <h3> <code>language-c-quote</code>: чего не хватает
    <ul>
        <li> всё ещё нет проверки корректности кода
            <ul>
                <li> то, что может проверить GCC, но можно бы ещё раньше
                    <ul>
                        <li> например, соответствие типов, дублирование символов
                <li> то, чего не может проверить GCC
                    <ul>
                        <li> например, сильное соответствие типов, целочисленное переполнение #
                            и т. д.
        <li> всё ещё надо писать тривиальные тесты

<section>
    <h3> <code>language-c-quote</code>: подводные камни
    <ul>
        <li> не поддерживаются вложенные цитаты в антицитатах
        <li> необходимость <code>$esc</code> для <code>#include</code>

<section>
    <h2> Способ 2. Библиотека-DSL Ivory

<section>
    <section>
        <h3> Хеллоуворлд на Ivory
        <pre>
            <code>
                \puts :: Def ('[IString] ':-> ())
                \puts = importProc "puts" "stdio.h"
                \
                \cmain :: String -> Def ('[] ':-> Sint32)
                \cmain msg = proc "main" $ body $ do
                \    call_ puts (fromString msg)
                \    ret 0
                \
                \hello :: String -> Module
                \hello msg = package "ivory-hello" $ do
                \    incl puts
                \    incl (cmain msg)
                \
                \main :: IO ()
                \main = do
                \    msg:rest &lt;- getArgs
                \    withArgs rest $ C.compile [hello msg] []
    <section>
        <h3> Сгенерированный код
        <code> ivory-hello.h
        <pre>
            <code>
                \#include &lt;stdio.h>
                \#include "ivory.h"
                \int32_t main(void);
        <code> ivory-hello.c
        <pre>
            <code>
                \#include "ivory-hello.h"
                \
                \int32_t main(void) {
                \    puts("CoLaboratory:ruHaskell 2016");
                \    return (int32_t) 0;
                \}
